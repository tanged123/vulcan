Here is the comprehensive implementation specification for the Vulcan coordinate package, derived strictly from Section 2.1 of the TAOS User's Manual.Vulcan Coordinate Systems: Implementation Specification1. Architectural OverviewObjective: Implement a robust, 6-DOF coordinate transformation engine for the Vulcan C++ package.Source of Truth: The Earth-Centered Fixed Cartesian (ECFC) frame is the primary integration frame. All state vectors (Position $\vec{r}$, Velocity $\vec{v}$, Acceleration $\vec{a}$) are stored in ECFC.Transformation Strategy: Unlike standard matrix-stacking engines, Vulcan shall implement the Unit Vector Projection Method. To transform a vector, compute the target frame's unit basis vectors ($\hat{x}, \hat{y}, \hat{z}$) expressed in ECFC components, then project the source vector onto them via dot products.2. Global Constants & Earth ModelImplement a singleton EarthModel struct to hold ellipsoidal parameters. Default to WGS-84 but allow injection of WGS-72 or spherical models.2.1 Ellipsoid ParametersEquatorial Radius ($R_{\oplus}$): Primary scalar.Polar Radius ($R_{p}$): Derived or explicit.Eccentricity ($e$): $e = \sqrt{1 - (R_p / R_{\oplus})^2}$Flatness ($f$): $f = 1 - (R_p / R_{\oplus})$Earth Rotation Rate ($||\vec{\omega}_{\oplus}||$): Scalar constant for ECIC transformations.3. Coordinate Frame Specifications3.1 Earth-Centered Fixed Cartesian (ECFC)ID: Frame::ECFCOrigin: Center of Earth mass.Alignment:$\hat{z}_{\oplus}$: Through True North Pole (spin axis).$\hat{x}_{\oplus}$: Intersection of Equator and Greenwich Meridian ($\lambda = 0^\circ$).$\hat{y}_{\oplus}$: Intersection of Equator and $90^\circ$ East Meridian.Usage: Primary container for state integration equations.3.2 Earth-Centered Inertial Cartesian (ECIC)ID: Frame::ECICDefinition: Non-accelerating frame coincident with Earth center. Z-axis is fixed to Earth spin axis.Time Dependence: The frame rotates relative to ECFC based on time $t$.Rotation Angle ($\Omega$):$$\Omega = \Omega_0 + ||\vec{\omega}_{\oplus}|| \cdot (t - t_0)$$Transformation Logic (ECFC $\to$ ECIC):$x_{I} = x_{\oplus}\cos\Omega - y_{\oplus}\sin\Omega$$y_{I} = x_{\oplus}\sin\Omega + y_{\oplus}\cos\Omega$$z_{I} = z_{\oplus}$Velocity Correction: When transforming velocity, include the transport theorem term (Coriolis effect) if moving between rotating/inertial frames.$\vec{v}_{I} = \vec{v}_{\oplus} + (\vec{\omega}_{\oplus} \times \vec{r})$3.3 Geocentric Coordinate System (Spherical)ID: Frame::GeocentricComponents: Longitude ($\lambda$), Geocentric Latitude ($\delta_{gc}$), Radius ($||\vec{r}||$).Forward Transformation (Pos $\to$ ECFC):$$x = ||\vec{r}|| \cos\delta_{gc} \cos\lambda$$$$y = ||\vec{r}|| \cos\delta_{gc} \sin\lambda$$$$z = ||\vec{r}|| \sin\delta_{gc}$$Inverse Transformation (ECFC $\to$ Pos):$$\lambda = \text{atan2}(y_{\oplus}, x_{\oplus})$$$$\delta_{gc} = \arcsin(z_{\oplus} / ||\vec{r}||)$$3.4 Local Geocentric HorizonID: Frame::LocalGeocentricHorizonOrigin: Vehicle Center of Mass (CM).Basis Vectors (in ECFC):$\hat{z}_{gc}$: Points to Earth Center (opposite to position vector $\vec{r}$).$\hat{y}_{gc}$: Points East (tangent to latitude circle).$\hat{x}_{gc}$: Points North (tangent to longitude circle).Construction Algorithm:Using $\lambda$ and $\delta_{gc}$:$\hat{x}_{gc} = -\sin\delta_{gc}(\cos\lambda \hat{x}_{\oplus} + \sin\lambda \hat{y}_{\oplus}) + \cos\delta_{gc} \hat{z}_{\oplus}$$\hat{y}_{gc} = -\sin\lambda \hat{x}_{\oplus} + \cos\lambda \hat{y}_{\oplus}$$\hat{z}_{gc} = -\cos\delta_{gc}(\cos\lambda \hat{x}_{\oplus} + \sin\lambda \hat{y}_{\oplus}) - \sin\delta_{gc} \hat{z}_{\oplus}$3.5 Geodetic Coordinate System (Ellipsoidal)ID: Frame::GeodeticComponents: Longitude ($\lambda$), Geodetic Latitude ($\delta_{gd}$), Altitude ($h$).Singularity Handling: $\lambda$ is undefined at poles ($x^2 + y^2 \approx 0$). Handle explicitly.ECFC $\to$ Geodetic Algorithm (Robust):Due to the transcendental nature of $\delta_{gd}$, implement the TAOS iterative solver (Reference Eqs 2-34 to 2-41).Algorithm SolveGeodetic(vec3 r_ecfc):Calculate $xy\_dist = \sqrt{r_x^2 + r_y^2}$.If $xy\_dist < \epsilon$ (Pole), set $\lambda = 0$, $\delta_{gd} = \text{sign}(r_z)90^\circ$, $h = |r_z| - R_p$. Return.Calculate Longitude: $\lambda = \text{atan2}(r_y, r_x)$.Initial Estimate: Assume spherical Earth for initial $z$ intercept.$z_i = R_{\oplus} e^2 (r_z / ||\vec{r}||)$Iteration Loop (Max 25 iterations, tolerance $10^{-8}$):$z_d = r_z + z_i$$N\_plus\_h = \sqrt{xy\_dist^2 + z_d^2}$$\sin\delta_{gd} = z_d / N\_plus\_h$$N = R_{\oplus} / \sqrt{1 - e^2 \sin^2\delta_{gd}}$$z_{i\_new} = N e^2 \sin\delta_{gd}$If $|z_{i\_new} - z_i| < \text{tolerance}$, break.$z_i = z_{i\_new}$Finalize:$h = N\_plus\_h - N$ (Calculated from Eq 2-38/2-39)Return $(\lambda, \delta_{gd}, h)$3.6 Local Geodetic Horizon (LGH)ID: Frame::LocalGeodeticHorizonOrigin: Vehicle CM.Basis Vectors:Defined identically to Local Geocentric Horizon, but using Geodetic Latitude ($\delta_{gd}$) instead of Geocentric.$\hat{z}_{gd}$: Normal to ellipsoid surface, pointing down.$\hat{x}_{gd}$: North in the tangent plane.$\hat{y}_{gd}$: East in the tangent plane.4. Body & Aerodynamic Frames4.1 Body-Fixed FrameID: Frame::BodyOrientation: Defined by Euler angles ($\Psi, \Theta, \Phi$) relative to the LGH frame.Sequence: Yaw ($\hat{z}_{gd}$) $\to$ Pitch ($\hat{y}'$) $\to$ Roll ($\hat{x}''$).Basis Vector Construction:$$\hat{x}_{b} = \cos\Theta\cos\Psi \hat{x}_{gd} + \cos\Theta\sin\Psi \hat{y}_{gd} - \sin\Theta \hat{z}_{gd}$$(See Eqs 2-52, 2-53 for $\hat{y}_b$ and $\hat{z}_b$ expansions involving Roll $\Phi$).Inverse Extraction (Matrix $\to$ Euler):When extracting Euler angles from vectors, check for Gimbal Lock (Pitch $\approx \pm 90^\circ$).If $\hat{x}_b \cdot \hat{z}_{gd} \approx \pm 1$:$\Theta = \pm 90^\circ$$\Psi = \Phi = 0$ (Arbitrary resolution).Else: Use atan2 logic on projected components (Eqs 2-54 to 2-57).4.2 Velocity FrameID: Frame::VelocityAlignment: X-axis aligned with Earth-Relative Velocity vector $\vec{V}_{\oplus}$.Basis Vectors:$\hat{x}_v = \vec{V}_{\oplus} / ||\vec{V}_{\oplus}||$$\hat{y}_v = (\hat{z}_{gd} \times \hat{x}_v)_{\text{normalized}}$ (Perpendicular to vertical plane).$\hat{z}_v = \hat{x}_v \times \hat{y}_v$ (Completes triad).Flight Path Angles:$\gamma_{gd}$ (Vertical FPA): Angle between $\vec{V}_{\oplus}$ and Horizon Plane.$\psi_{gd}$ (Heading): Angle of projection of $\vec{V}_{\oplus}$ on Horizon Plane relative to North.4.3 Wind FrameID: Frame::WindAlignment: X-axis aligned with Air-Relative Velocity $\vec{V}_{w\oplus}$ (includes wind vector subtraction).Bank Angle ($\mu$): Rotates the Y/Z axes about the velocity vector.Basis Vectors:$\hat{x}_w = \hat{x}_{v_{air}}$$\hat{y}_w = \cos\mu \hat{y}_{v_{air}} + \sin\mu \hat{z}_{v_{air}}$$\hat{z}_w = -\sin\mu \hat{y}_{v_{air}} + \cos\mu \hat{z}_{v_{air}}$4.4 Aerodynamic Angles (Robust Implementation)Implement two modes for Aerodynamic/Body relationships to avoid singularities.Standard ($\alpha, \beta$):Singularity: Undefined when velocity is perpendicular to body X-axis.Total Angle of Attack ($\alpha_T, \phi_w$):Preferred for High-Angle Dynamics.$\alpha_T$: Angle between Body X and Wind X (Range: $0$ to $180^\circ$).$\phi_w$ (Windward Meridian): Aerodynamic roll angle.Conversion (Eq 2-79):$$\tan\alpha_T = \frac{\sqrt{(\hat{x}_w \cdot \hat{y}_b)^2 + (\hat{x}_w \cdot \hat{z}_b)^2}}{\hat{x}_w \cdot \hat{x}_b}$$5. C++ Implementation Structures5.1 The CoordinateFrame ClassAvoid storing transformation matrices. Store basis vectors.C++struct CoordinateFrame {
    // The basis vectors of this frame expressed in ECFC
    Vec3 unit_x;
    Vec3 unit_y;
    Vec3 unit_z;

    // Origin position in ECFC (usually Earth Center or Vehicle CM)
    Vec3 origin_ecfc;

    // Project a vector FROM ECFC TO this frame
    Vec3 projectFromECFC(const Vec3& vec_ecfc) const {
        return Vec3(
            dot(vec_ecfc, unit_x),
            dot(vec_ecfc, unit_y),
            dot(vec_ecfc, unit_z)
        );
    }

    // Project a vector FROM this frame TO ECFC
    Vec3 projectToECFC(const Vec3& vec_local) const {
        return (unit_x * vec_local.x) + 
               (unit_y * vec_local.y) + 
               (unit_z * vec_local.z);
    }
};
5.2 Transformation ManagerDo not write $N^2$ conversion functions. Write paths to/from ECFC.C++class TransformEngine {
public:
    // Generic transform between any two frames
    // 1. Project Source -> ECFC
    // 2. Project ECFC -> Target
    static Vec3 Transform(const Vec3& vec, 
                          const CoordinateFrame& source, 
                          const CoordinateFrame& target) {
        
        // Step 1: To Hub (ECFC)
        Vec3 ecfc_vec = source.projectToECFC(vec);
        
        // Step 2: From Hub (ECFC)
        return target.projectFromECFC(ecfc_vec);
    }
};
6. Validation Checklist[ ] Normalization: Ensure all basis vectors are re-normalized after computation to prevent numerical drift (e.g., unit_x.normalize()).[ ] Orthogonality: Ensure $\hat{z} = \hat{x} \times \hat{y}$ holds true for constructed frames.[ ] Pole Check: Test Geodetic conversion at $\lambda=0, \delta=90$. Expect $x=0, y=0$.[ ] Dateline Check: Test crossing $\lambda = 180/-180$.[ ] Center of Earth: Handle $||\vec{r}|| \to 0$ gracefully (Error or zero output, do not crash).Reference: TAOS User's Manual, Section 2.1 "Coordinate Systems" and Section 2.2 "Equations of Motion".